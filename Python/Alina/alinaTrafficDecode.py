import sys
import struct
import urllib

# Copyright
# =========
# Copyright (C) 2016 Trustwave Holdings, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>
#
#
# python alinaTrafficDecode.py [filename] by Eric Merritt 2016-03-17
#
# =Synopsis
#
# This script decodes traffic generated by several families of malware related
# to Alina.  It has been tested with the Eagle, Joker, and Spark variants.  It
# XORs the traffic with 0xAA, grab the new XOR key (bytes 18-36), parse the
# header information, decode the body, and parse the body information. The
# result is displayed to the screen.
#
# Input: Encoded traffic file
#
# Example: python alinaTrafficDecode.py encodedTraffic.txt
#


def processBody(body):
    alina = []
    alina.append('terminate ')
    alina.append('forcing ')
    alina.append('Executing ')
    alina.append('failed ')
    alina.append('success ')
    alina.append('Exception ')
    alina.append('at ')
    alina.append('Imagebase ')
    alina.append('pid ')
    alina.append('to ')
    alina.append('InternetOpen ')
    alina.append('InternetConnect ')
    alina.append('HttpOpenRequest ')
    alina.append('HttpSendRequest ')
    alina.append('HttpQueryInfo ')
    alina.append('new ')
    alina.append('logging ')
    alina.append('on ')
    alina.append('off ')
    alina.append('delete ')
    alina.append('file ')
    alina.append('Download & Execute ')
    alina.append('no ')
    alina.append('last request ')
    alina.append('seconds ago ')
    alina.append('command ')
    alina.append('get and call ')
    alina.append('called pipe and encountered version ')
    alina.append('i am ')
    alina.append('pipe ')
    alina.append('thread ')
    alina.append('restarting ')
    alina.append('httpRequest ')
    alina.append('length ')
    alina.append('checksum ')
    alina.append('fallback ')
    alina.append('verification ')
    alina.append('should be ')
    alina.append('is ')
    alina.append('CreateFileA ')
    alina.append('WriteFile ')
    alina.append('wrote ')
    alina.append('UrlDownloadToFileA ')
    alina.append('open ')
    alina.append('read ')
    alina.append('process ')

    for line in body.split('\n'):
        for i in range(46):
            joker = '~j~' + str(i + 1) + '~k~'
            eagle = '{[!' + str(i + 1) + '!]}'

            line = line.replace(joker, alina[i])
            line = line.replace(eagle, alina[i])
        print line


def decodeTraffic(traffic):
    HEADER_SIZE = 76

    if len(traffic) < HEADER_SIZE:
        print "[-] Traffic is less than header size"
        return

    new_traffic = ''

    for byte in traffic:
        new_traffic += struct.pack('B', ord(byte) ^ 0xaa)

    key = traffic[18:36]

    # Headers
    v, sv, hwid, nonce, act, pcn = struct.unpack(
        "H16s8s2s8s32s", new_traffic[:68])
    size = struct.unpack('<L', new_traffic[68:72])[0] - 123

    print "Header Information\n" + "=" * 30
    print "[+] Version: 0x%04x" % v
    print "[+] Name: %s" % sv
    print "[+] Hardware ID: %s" % hwid
    print "[+] Action: %s" % act
    print "[+] Computer Name: %s" % pcn
    print "[+] Data Length: %d\n" % size

    # Body
    if (HEADER_SIZE + size + 123) != len(new_traffic):
        body = cxor(new_traffic, HEADER_SIZE, size, key, 18)
        handleBody(body)
    else:
        print "[-] Exiting... Size mismatch"


def handleBody(body):
    parameters = body.split('&')
    if len(parameters) > 0:
        for p in parameters:
            if len(p) > 0:
                v = p.split('=')
                if len(v) > 0:
                    processBody(urllib.unquote(v[1]).decode('utf8'))


def cxor(data, offset, length, key, klen):
    ret = ''
    for i in range(length):
        ret += chr(ord(data[offset + i]) ^ ord(key[i % klen]))
    return ret


def printUsage():
    print "[-] Usage: %s file_path" % sys.argv[0]


# Main ########################
if len(sys.argv) == 2:
    exfil_file = sys.argv[1]
    try:
        f = open(exfil_file, "rb")
        traffic = f.read()
        f.close()
        decodeTraffic(traffic)
    except IOError as e:
        print e
        sys.exit(1)
else:
    printUsage()
