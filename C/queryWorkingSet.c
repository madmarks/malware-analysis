/**********************************************************************
# Copyright
# =========
# Copyright(C) 2015 Trustwave Holdings, Inc.
#
# This program is free software : you can redistribute it and / or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.If not, see <http://www.gnu.org/licenses/>
#
#
# Author: Eric Merritt
# Date: 11/05/15
#
# Description:
# This is a proof of concept application demonstrating a new technique
# scanning memory discovered in version 3 of Cherry Picker malware
#
# Usage: Usage: queryworkingset.exe [-v | -q] [PID | ProcessName]
#
*************************************************************************/

#define WINDOWS_LEAN_AND_MEAN

#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>
#include <tlhelp32.h>
#include <Shlwapi.h>

#pragma comment ( lib, "psapi.lib" )
#pragma comment( lib, "Shlwapi.lib" )

BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
  TOKEN_PRIVILEGES tp;
  LUID luid;

  if (!LookupPrivilegeValue(
    NULL,            // lookup privilege on local system
    lpszPrivilege,   // privilege to lookup
    &luid))        // receives LUID of privilege
  {
    printf("LookupPrivilegeValue error: %u\n", GetLastError());
    return FALSE;
  }

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  if (bEnablePrivilege)
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  else
    tp.Privileges[0].Attributes = 0;

  // Enable the privilege or disable all privileges.

  if (!AdjustTokenPrivileges(
    hToken,
    FALSE,
    &tp,
    sizeof(TOKEN_PRIVILEGES),
    (PTOKEN_PRIVILEGES)NULL,
    (PDWORD)NULL))
  {
    printf("AdjustTokenPrivileges error: %u\n", GetLastError());
    return FALSE;
  }

  if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)

  {
    printf("The token does not have the specified privilege. \n");
    return FALSE;
  }

  return TRUE;
}


BOOL getTargetProcess(HANDLE *hProcess, DWORD *pid, TCHAR *process)
{
  HANDLE hProcessSnap;
  PROCESSENTRY32 pe32;

  hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (hProcessSnap == INVALID_HANDLE_VALUE)
    return 0;

  pe32.dwSize = sizeof(PROCESSENTRY32);
  if (!Process32First(hProcessSnap, &pe32))
  {
    CloseHandle(hProcessSnap);          // clean the snapshot object
    return 0;
  }
  do
  {
    if (_wcsicmp(pe32.szExeFile, process) == 0)
    {
      *hProcess = OpenProcess(
        PROCESS_QUERY_INFORMATION | // Required by Alpha
        PROCESS_CREATE_THREAD | // For CreateRemoteThread
        PROCESS_VM_OPERATION |  // For VirtualAllocEx/VirtualFreeEx
        PROCESS_VM_WRITE |  // For WriteProcessMemory
        PROCESS_VM_READ |
        SYNCHRONIZE |
        PROCESS_DUP_HANDLE,
        FALSE,
        pe32.th32ProcessID);
      if (hProcess == NULL)
        return 0;
      else
      {
        *pid = pe32.th32ProcessID;
        CloseHandle(hProcessSnap);
        return 1;
      }
    }
  } while (Process32Next(hProcessSnap, &pe32));

  CloseHandle(hProcessSnap);
  return 0;
}

int main(int argc, char *argv[])
{
  // Need the page size information for the QueryWorkingSet memory scraping
  SYSTEM_INFO info;
  GetSystemInfo(&info);

  // For the PoC check and see if they want the to use VirtualQuery or QueryWorkingSet
  // Also get the PID or process name to scrape cards
  if (argc != 3){
    printf("Usage: %s [-v | -q] [PID | ProcessName]", argv[0]);
    return 0;
  }

  char *queryType = (char *)malloc(strlen(argv[1] + 1));
  if (!queryType)
  {
    printf("Failed to allocate memory\n");
    return -1;
  }
  memcpy(queryType, argv[1], strlen(argv[1]));
  queryType[strlen(argv[1])] = '\0';

  //get debug privs for the application
  printf("[+] Ensuring we have the proper privs....");
  HANDLE hToken;
  HANDLE self = OpenProcess(
    PROCESS_QUERY_INFORMATION | // Required by Alpha
    PROCESS_CREATE_THREAD | // For CreateRemoteThread
    PROCESS_VM_OPERATION |  // For VirtualAllocEx/VirtualFreeEx
    PROCESS_VM_WRITE |  // For WriteProcessMemory
    PROCESS_VM_READ,
    FALSE,
    GetCurrentProcessId());

  // Elevate the privs of our process
  OpenProcessToken(self, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken);
  if (!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE))
  {
    printf(" failed\n");
    return 0;
  }
  printf(" success\n");

  // Open target Process
  printf("[+] Opening target process ");
  HANDLE pos;
  DWORD pid;

  // Open the process by PID or by process name
  pid = atoi(argv[2]);

  // atoi fails with 0 if it isn't a number and PIDs shouldn't be 0
  // You aren't finding any cc data in the System Idle Process
  if (pid == 0)
  {
    printf("%s ", argv[2]);
    wchar_t  ws[100];
    swprintf(ws, 100, L"%hs", argv[2]);
    if (!getTargetProcess(&pos, &pid, ws))
    {
      printf("failed\n");
      return -1;
    }
    printf("[%d]... ", pid);
  }
  else
  {
    pos = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!pos)
    {
      printf("failed\n");
      return -1;
    }
    else
    {
      // Print out the name of the process for display purposes
      TCHAR Buffer[MAX_PATH];
      TCHAR* filename;
      if (GetModuleFileNameEx(pos, 0, Buffer, MAX_PATH))
      {
        filename = PathFindFileName(Buffer);
        printf("%S [%d]... ", filename, pid);
      }
    }
  }
  printf("success\n");

  // Virtual Query Section
  if (strcmp(queryType, "-v") == 0)
  {
    printf("[+] Using VirtualQueryEx to scrape memory\n\n");
    SIZE_T v2;
    struct _MEMORY_BASIC_INFORMATION Buffer;
    char *BaseAddress;

    while (1)
    {
      BaseAddress = (char *)0x10000;
      do
      {
        VirtualQueryEx(pos, BaseAddress, &Buffer, 0x1Cu);
        if (Buffer.State == 0x1000 && Buffer.Protect & 4 && !(Buffer.Protect & 0x100))
          printf("Memory Page at Virtual Address 0x%08x", BaseAddress);
        v2 = Buffer.RegionSize;
        if (Buffer.RegionSize < 0x1000)
        {
          v2 = 0x1000;
          Buffer.RegionSize = 0x1000;
        }
        BaseAddress = (char *)Buffer.BaseAddress + v2;
      } while ((unsigned int)BaseAddress < 0x6FF00000);
    }

  }
  else if (strcmp(queryType, "-q") == 0)
  {
    printf("[+] Using QueryWorkingSet to scrape memory\n\n");
    DWORD wsi_size;
    PSAPI_WORKING_SET_INFORMATION wsi_1, *wsi;
    wsi_1.NumberOfEntries = 0;

    while (1)
    {
      // Get the actual number of pages: This call will fail because we "don't have enough space"
      QueryWorkingSet(pos, (LPVOID)&wsi_1, sizeof(wsi));

      // Get enough space for the page information
      wsi_size = sizeof(PSAPI_WORKING_SET_INFORMATION) + sizeof(PSAPI_WORKING_SET_BLOCK) * wsi_1.NumberOfEntries;
      wsi = (PSAPI_WORKING_SET_INFORMATION*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, wsi_size);

      // Now populate the working set information
      if (!QueryWorkingSet(pos, (LPVOID)wsi, wsi_size))
      {
        printf("[-] Second QueryWorkingSet failed: %lu\n", GetLastError());
        return 1;
      }

      // Scan through the pages and scan the Read/Write pages for CC data
      for (DWORD i = 0; i < wsi->NumberOfEntries; i++)
      {
        DWORD dwDumpAddress = wsi->WorkingSetInfo[i].VirtualPage << 12;
        DWORD protection = (DWORD)wsi->WorkingSetInfo[i].Protection;
        // We only want READ/WRITE non-shared pages with a valid address space
        if (protection & 4 && !(protection & 0x100) && (dwDumpAddress >> 12 != 0xC))
          printf("Memory Page at Virtual Address 0x%08x", dwDumpAddress);
      }
    }
  }
  return 0;
}
