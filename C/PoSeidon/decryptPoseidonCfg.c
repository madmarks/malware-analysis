/*
# Copyright
# =========
# Copyright (C) 2016 Trustwave Holdings, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>
#
#
# Usage: decryptPoseidonCfg.exe </path/to/enctrypted/file.exe> <password> </path/to/output/file.txt>
# Author: Eric Merritt
# Date: 2016-01-21
#WinHost.exe.cfg jfnwn02cybn83duf37fj decrypted.txt
# =Synopsis
#
# This is a decryptor program to decrypt configuration files that are downloaded
# in association of a poseidon infection.  The configuration files contain additional
# C&C domains that are used by the malware.
#
# IMPORTANT!!!!
# This file MUST be ran on the system that encrypted it for the decryption to work.
# The APIs (CryptUnprotectData, CryptProtectData) perform encryption that can only be
# encrypted/decrypted on the system it originally was used on.
#
# Input: encrypted file, password, and output file
# Output: prints decrypted text to screen and writes output to given output file
#
# Example:  decryptPoseidonCfg.exe WinHost.exe.cfg jfnwn02cybn83duf37fj decrypted.txt
#
#
# Output: decrypted.txt (containing decrypted file contents)
*/

#include <stdio.h>
#include "Windows.h"
#include <wincrypt.h>
#include <stdlib.h>

#pragma comment(lib, "Crypt32")


int main(int argc, char* argv[])
{
	DATA_BLOB entropy;
	DATA_BLOB DataOut;
	DATA_BLOB DataVerify;
	HANDLE hSourceFile = INVALID_HANDLE_VALUE;
	HANDLE hDestinationFile = INVALID_HANDLE_VALUE;
	PBYTE pbBuffer = NULL;
	DWORD dwBufferLen, dwCount;
	char *password = NULL;
	char *encryptedFile = NULL;
	char *outputFile = NULL;

	if (argc < 4)
	{
		printf("%s <encrypted file> <password> <output file>", argv[0]);
		printf("\n Press any key to exit");
		_getch();
		return 1;
	}

	encryptedFile = (char *)malloc(strlen(argv[1]) + 1);
	password = (char *)malloc(strlen(argv[2]) + 1);
	outputFile = (char *)malloc(strlen(argv[3]) + 1);
	if (!encryptedFile || !password || !outputFile)
	{
		printf("Failed to allocate space for variables");
		return -1;
	}
	strncpy(encryptedFile, argv[1], strlen(argv[1]) + 1);
	strncpy(password, argv[2], strlen(argv[2]) + 1);
	strncpy(outputFile, argv[3], strlen(argv[3]) + 1);

	// Setup entropy data_blob
	entropy.pbData = (BYTE *)password;
	entropy.cbData = strlen(password) + 1;

	// Read in the encrypted source file
	hSourceFile = CreateFileA(
		encryptedFile,
		FILE_READ_DATA,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if(hSourceFile == -1 || hSourceFile == NULL)
	{
		printf("Failed to read in encrypted file\n");
		return -1;
	}

	// Find out the file size and allocate a buffer
	dwBufferLen = GetFileSize(hSourceFile, NULL);
	pbBuffer = (PBYTE)malloc(dwBufferLen);
	if (!pbBuffer)
	{
		printf("Failed to allocate space for encrypted buffer");
		return -1;
	}

	if (!ReadFile(
		hSourceFile,
		pbBuffer,
		dwBufferLen,
		&dwCount,
		NULL))
	{
		CloseHandle(hSourceFile);
		printf("Error reading from source file!\n");
		return -1;
	}

	CloseHandle(hSourceFile);

	// Setup the encrypted data_blob
	DataOut.cbData = dwCount;
	DataOut.pbData = pbBuffer;

	// Decrypt the file
	if (CryptUnprotectData(
		&DataOut,
		NULL,
		&entropy,                 // Optional entropy
		NULL,                 // Reserved
		NULL,                 // Here, the optional
							  // prompt structure is not
							  // used.
		CRYPTPROTECT_LOCAL_MACHINE,
		&DataVerify))
	{
		printf("The decrypted data is: %s\n", DataVerify.pbData);

		hDestinationFile = CreateFileA(
			outputFile,
			FILE_WRITE_DATA,
			FILE_SHARE_READ,
			NULL,
			OPEN_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);
		if (hDestinationFile == -1 || hDestinationFile == NULL)
		{
			printf("Failed to open output file for writing\n");
			return -1;
		}

		// Write out the decrypted data to the specified file and
		WriteFile(hDestinationFile, DataVerify.pbData, strlen((char *)DataVerify.pbData), &dwCount, NULL);
		CloseHandle(hDestinationFile);
	}
	else
	{
		printf("Decryption error!");
	}
}